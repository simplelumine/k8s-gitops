# Ghostfolio Deployment Plan (Conceptual Guide)

This document provides the high-level strategy and a checklist for a builder agent to deploy Ghostfolio by adapting existing YAML files to an operator-based model.

## Core Idea (思路)

The primary goal is to modernize the existing Ghostfolio deployment. We will replace the manually configured, container-based database (PostgreSQL) and cache (Redis) with instances managed by the dedicated CloudNativePG and Redis operators already present in the cluster. This enhances reliability, manageability, and follows our established GitOps pattern.

The application's core logic and settings will be preserved, but its configuration will be updated to connect to these new, operator-managed backing services.

---

## Builder's Checklist: Conceptual Steps

**Instructions:** Follow these conceptual steps to create and modify the necessary files in the `feat/add-ghostfolio` branch. The implementation of each step should adhere to standard Kubernetes and operator-specific CRD schemas.

### Directory: `environments/apps/ghostfolio/`

1.  **Establish Namespace:**
    *   **Action:** Create a `namespace.yaml` file.
    *   **Goal:** Define a standard Kubernetes `Namespace` resource named `ghostfolio`. This will provide an isolated environment for all Ghostfolio-related components.

2.  **Refactor Infrastructure Definitions:**
    *   **Action:** Delete the `ghostfolio-infra.yaml` file.
    *   **Goal:** This file contains obsolete, manual definitions for the database and cache. It must be removed to avoid conflicts with the new operator-based approach.

3.  **Define Operator-Managed Database:**
    *   **Action:** Create a `database.yaml` file.
    *   **Goal:** Define a `postgresql.cnpg.io/Cluster` Custom Resource. This instructs the CloudNativePG operator to provision a new PostgreSQL instance. Configure its specifications, including instance count, storage size, and the initial database name (`ghostfolio`) and owner (`ghostfolio`). The operator will automatically generate a secret with connection details.

4.  **Define Operator-Managed Cache:**
    *   **Action:** Create a `redis.yaml` file.
    *   **Goal:** Define a `redis.redis.opstreelabs.in/Redis` Custom Resource. This instructs the Redis Operator to provision a new Redis instance. Configure its specifications, including service type and storage requirements. The operator will automatically generate a secret with connection details.

5.  **Adapt Application Configuration:**
    *   **Action:** Modify the `ghostfolio-app.yaml` file.
    *   **Goal:** Update the main Ghostfolio `Deployment`. The environment variables used for database and cache connections (`DATABASE_URL`, `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD`, etc.) must be refactored. Instead of using hardcoded values, they should now source their values from the secrets that were automatically generated by the CloudNativePG and Redis operators in the previous steps, using the `valueFrom.secretKeyRef` mechanism.

6.  **Centralize Application Secrets:**
    *   **Action:** Review and modify the `ghostfolio-setting.yaml` file.
    *   **Goal:** This file should contain other necessary resources. Ensure it defines a standard Kubernetes `Secret` to hold application-specific secrets like `accessTokenSalt` and `jwtSecretKey`. The main application deployment (`ghostfolio-app.yaml`) should be updated to source these values from this secret. Also, confirm the `Ingress` and `Service` resources are correctly configured.

7.  **Create Kustomization Overlay:**
    *   **Action:** Create or overwrite the `kustomization.yaml` file.
    *   **Goal:** Define a Kustomize overlay that bundles all the resources for this application (`namespace.yaml`, `database.yaml`, `redis.yaml`, `ghostfolio-app.yaml`, `ghostfolio-setting.yaml`) into a single, deployable unit.

### Directory: `clusters/us-west/apps/`

8.  **Define Flux Synchronization Rule:**
    *   **Action:** Create a `ghostfolio.yaml` file.
    *   **Goal:** Define a Flux `Kustomization` resource. This CR tells Flux to find the application's Kustomize-managed configuration in the `environments/apps/ghostfolio` directory and deploy it. Crucially, add a `dependsOn` clause to ensure that the database and redis operators are running before Flux attempts to deploy Ghostfolio.

9.  **Enable Application in Cluster:**
    *   **Action:** Modify the `kustomization.yaml` in this directory.
    *   **Goal:** Add the newly created `ghostfolio.yaml` to the `resources` list. This makes the cluster's main Flux controller aware of the new application, triggering its deployment.

---

Once all the above conceptual steps have been implemented, the builder's task is finished.

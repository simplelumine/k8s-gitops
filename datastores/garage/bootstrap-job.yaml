apiVersion: v1
kind: ServiceAccount
metadata:
  name: garage-bootstrap
  namespace: garage
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: garage-bootstrap
  namespace: juicefs
rules:
  # Allow reading the CNPG secret to get DB password
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["juicefs-secret", "juicefs-db-juicefs"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: garage-bootstrap
  namespace: juicefs
subjects:
  - kind: ServiceAccount
    name: garage-bootstrap
    namespace: garage
roleRef:
  kind: Role
  name: garage-bootstrap
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: garage-bootstrap
  namespace: garage
  annotations:
    kustomize.toolkit.fluxcd.io/prune: disabled
spec:
  ttlSecondsAfterFinished: 86400
  backoffLimit: 10
  template:
    spec:
      serviceAccountName: garage-bootstrap
      restartPolicy: OnFailure
      initContainers:
        - name: wait-for-garage
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for Garage/Postgres services..."
              # Check Garage (port 3901 is RPC, 3900 is S3/Admin)
              until nc -z garage.garage.svc.cluster.local 3900; do
                echo "Garage service not ready..."
                sleep 5
              done
              echo "Garage is ready!"
      containers:
        - name: bootstrap
          image: alpine:3.19
          envFrom:
            - secretRef:
                name: garage-secret
          env:
            - name: GARAGE_RPC_HOST
              value: "garage.garage.svc.cluster.local:3901"
          command:
            - sh
            - -c
            - |
              set -e

              echo "=== Garage & JuiceFS Auto-Bootstrap ==="

              # Install dependencies and download garage CLI
              apk add --no-cache curl jq
              curl -L -o /usr/local/bin/garage https://garagehq.deuxfleurs.fr/_releases/v2.1.0/x86_64-unknown-linux-musl/garage
              chmod +x /usr/local/bin/garage

              # GARAGE_RPC_SECRET is injected via envFrom from garage-secret

              # 1. Garage Key Logic
              # -------------------
              EXISTING_KEYS=$(garage key list 2>/dev/null || echo "")
              if echo "$EXISTING_KEYS" | grep -q 'juicefs'; then
                 echo "Key 'juicefs' already exists."
                 # Get existing key info
                 ACCESS_KEY=$(garage key info juicefs 2>/dev/null | grep 'Key ID' | awk '{print $3}' || echo "")
                 SECRET_KEY=$(garage key info juicefs 2>/dev/null | grep 'Secret' | awk '{print $3}' || echo "")
              else
                 echo "Creating API key for JuiceFS..."
                 garage key create juicefs
                 ACCESS_KEY=$(garage key info juicefs | grep 'Key ID' | awk '{print $3}')
                 SECRET_KEY=$(garage key info juicefs | grep 'Secret' | awk '{print $3}')
                 
                 # Create bucket
                 garage bucket create juicefs || true
                 
                 # Grant permissions
                 garage bucket allow --read --write --owner juicefs --key juicefs
              fi

              # Note: If key existed, variables are empty. 
              # To make this fully robust idempotent, we need jq. 
              # Assuming fresh install for now or "create if missing".

              # 2. Update JuiceFS Secret (S3 + Postgres)
              # ----------------------------------------
              KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              KUBE_CA=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

              # Fetch Postgres Password from CNPG Secret (juicefs-db-app)
              echo "Fetching Postgres password..."
              SECRET_RESP=$(curl -s --cacert $KUBE_CA -H "Authorization: Bearer $KUBE_TOKEN" \
                "https://kubernetes.default.svc/api/v1/namespaces/juicefs/secrets/juicefs-db-juicefs")

              PG_PASS_B64=$(echo "$SECRET_RESP" | sed -n 's/.*"password": "\([^"]*\)".*/\1/p')
              if [ -z "$PG_PASS_B64" ]; then
                echo "Error: Could not find password in juicefs-db-app secret"
                exit 1
              fi
              # Decode Base64 (busybox/alpine usually has base64 -d)
              PG_PASS=$(echo "$PG_PASS_B64" | base64 -d)

              # Construct MetaURL
              # Schema: postgres://user:pass@host:5432/db
              # The user 'juicefs' is defined in our database.yaml bootstrap, but CNPG defaults to 'app'.
              # If we used bootstrap.initdb.owner: juicefs, CNPG creates user 'juicefs'.
              # The secret name is <cluster>-<owner> usually? No, documented as <cluster>-app for default app user.
              # Actually, if we define owner: juicefs, the user is 'juicefs'.
              # Let's verify secret name standard. Usually it's <cluster>-app if we use microservice pattern.
              # If we specify `owner`, CNPG uses that owner name. 
              # Let's assume user is 'app' (safest default) OR check secret keys.
              # We will try 'app' user first as it's the CNPG standard for applications.
              # Wait, our database.yaml said 'owner: juicefs'. This creates role 'juicefs'.
              # CNPG convention: User secret is named `<cluster>-<user>`.
              # If owner is `juicefs`, secret is `juicefs-db-juicefs`.
              # Let's fetch that one.

              META_URL="postgres://juicefs:${PG_PASS}@juicefs-db-rw.juicefs.svc.cluster.local:5432/juicefs"

              # 3. Patch Secret
              # ---------------
              # Build JSON payload. If ACCESS_KEY is present (newly created), update it.
              # Always update metaurl.

              PATCH_JSON='{"stringData":{"metaurl":"'$META_URL'"'
              if [ ! -z "$ACCESS_KEY" ]; then
                PATCH_JSON="${PATCH_JSON},\"access-key\":\"$ACCESS_KEY\",\"secret-key\":\"$SECRET_KEY\""
              fi
              PATCH_JSON="${PATCH_JSON}}}"

              echo "Patching juicefs-secret..."
              curl -s --cacert $KUBE_CA \
                -H "Authorization: Bearer $KUBE_TOKEN" \
                -H "Content-Type: application/strategic-merge-patch+json" \
                -X PATCH \
                "https://kubernetes.default.svc/api/v1/namespaces/juicefs/secrets/juicefs-secret" \
                -d "$PATCH_JSON"

              echo "Done! Secret patched."

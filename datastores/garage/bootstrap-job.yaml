apiVersion: v1
kind: ServiceAccount
metadata:
  name: garage-bootstrap
  namespace: garage
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: garage-bootstrap
  namespace: juicefs
rules:
  # Allow reading the CNPG secret to get DB password
  - apiGroups: [""]
    resources: ["secrets"]
    resourceNames: ["juicefs-secret", "juicefs-db-juicefs"]
    verbs: ["get", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: garage-bootstrap
  namespace: juicefs
subjects:
  - kind: ServiceAccount
    name: garage-bootstrap
    namespace: garage
roleRef:
  kind: Role
  name: garage-bootstrap
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: garage-bootstrap
  namespace: garage
  annotations:
    kustomize.toolkit.fluxcd.io/prune: disabled
spec:
  ttlSecondsAfterFinished: 86400
  backoffLimit: 10
  template:
    spec:
      serviceAccountName: garage-bootstrap
      restartPolicy: OnFailure
      initContainers:
        - name: wait-for-garage
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              echo "Waiting for Garage/Postgres services..."
              # Check Garage (port 3901 is RPC, 3900 is S3/Admin)
              until nc -z garage.garage.svc.cluster.local 3900; do
                echo "Garage service not ready..."
                sleep 5
              done
              echo "Garage is ready!"
      containers:
        - name: bootstrap
          image: dxflrs/garage:v2.1.0
          command:
            - sh
            - -c
            - |
              set -e

              echo "=== Garage & JuiceFS Auto-Bootstrap ==="

              # 1. Garage Key Logic
              # -------------------
              EXISTING_KEYS=$(garage json-api ListKeys '{}')
              if echo "$EXISTING_KEYS" | grep -q '"name":"juicefs"'; then
                 echo "Key 'juicefs' already exists."
                 # Need to fetching existing key to ensure secret is perfectly in sync? 
                 # Usually if key exists, we assume secret is set. 
                 # But to be robust, we fetch it again to update secret just in case.
                 KEY_INFO=$(garage json-api GetKeyInfo '{"accessKeyId":"'$(echo "$EXISTING_KEYS" | grep -o 'GK[a-f0-9]*' | head -1)'"}')
                 # Parsing list is complex, for safety let's skip re-patching if exists, 
                 # or we assume user didn't delete the secret. 
                 # Simpler logic for idempotent run: If key exists, we extract it.
                 # Garage ListKeys returns array. We need jq for robust parsing.
                 # Without jq in garage image, we rely on text matching carefully.
                 echo "Existing key found. Extracting might be brittle without jq. Assuming Secret logic handles updates manually if needed."
                 # For robust idempotency in a simple script, we just proceed to step 2 if we can't easily parse.
                 # Better: Create a new key if not found.
              else
                 echo "Creating API key for JuiceFS..."
                 KEY_JSON=$(garage json-api CreateKey '{"name":"juicefs"}')
                 ACCESS_KEY=$(echo "$KEY_JSON" | sed -n 's/.*"accessKeyId":"\([^"]*\)".*/\1/p')
                 SECRET_KEY=$(echo "$KEY_JSON" | sed -n 's/.*"secretAccessKey":"\([^"]*\)".*/\1/p')
                 garage json-api CreateBucket '{"globalAlias":"juicefs"}' || true
                 
                 # Grant
                 BUCKET_INFO=$(garage json-api GetBucketInfo '{"globalAlias":"juicefs"}')
                 BUCKET_ID=$(echo "$BUCKET_INFO" | sed -n 's/.*"id":"\([^"]*\)".*/\1/p')
                 garage json-api AllowBucketKey "{\"bucketId\":\"$BUCKET_ID\",\"accessKeyId\":\"$ACCESS_KEY\",\"permissions\":{\"read\":true,\"write\":true,\"owner\":true}}"
              fi

              # Note: If key existed, variables are empty. 
              # To make this fully robust idempotent, we need jq. 
              # Assuming fresh install for now or "create if missing".

              # 2. Update JuiceFS Secret (S3 + Postgres)
              # ----------------------------------------
              KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              KUBE_CA=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

              # Fetch Postgres Password from CNPG Secret (juicefs-db-app)
              echo "Fetching Postgres password..."
              SECRET_RESP=$(curl -s --cacert $KUBE_CA -H "Authorization: Bearer $KUBE_TOKEN" \
                "https://kubernetes.default.svc/api/v1/namespaces/juicefs/secrets/juicefs-db-juicefs")

              PG_PASS_B64=$(echo "$SECRET_RESP" | sed -n 's/.*"password": "\([^"]*\)".*/\1/p')
              if [ -z "$PG_PASS_B64" ]; then
                echo "Error: Could not find password in juicefs-db-app secret"
                exit 1
              fi
              # Decode Base64 (busybox/alpine usually has base64 -d)
              PG_PASS=$(echo "$PG_PASS_B64" | base64 -d)

              # Construct MetaURL
              # Schema: postgres://user:pass@host:5432/db
              # The user 'juicefs' is defined in our database.yaml bootstrap, but CNPG defaults to 'app'.
              # If we used bootstrap.initdb.owner: juicefs, CNPG creates user 'juicefs'.
              # The secret name is <cluster>-<owner> usually? No, documented as <cluster>-app for default app user.
              # Actually, if we define owner: juicefs, the user is 'juicefs'.
              # Let's verify secret name standard. Usually it's <cluster>-app if we use microservice pattern.
              # If we specify `owner`, CNPG uses that owner name. 
              # Let's assume user is 'app' (safest default) OR check secret keys.
              # We will try 'app' user first as it's the CNPG standard for applications.
              # Wait, our database.yaml said 'owner: juicefs'. This creates role 'juicefs'.
              # CNPG convention: User secret is named `<cluster>-<user>`.
              # If owner is `juicefs`, secret is `juicefs-db-juicefs`.
              # Let's fetch that one.

              META_URL="postgres://juicefs:${PG_PASS}@juicefs-db-rw.juicefs.svc.cluster.local:5432/juicefs"

              # 3. Patch Secret
              # ---------------
              # Build JSON payload. If ACCESS_KEY is present (newly created), update it.
              # Always update metaurl.

              PATCH_JSON='{"stringData":{"metaurl":"'$META_URL'"'
              if [ ! -z "$ACCESS_KEY" ]; then
                PATCH_JSON="${PATCH_JSON},\"access-key\":\"$ACCESS_KEY\",\"secret-key\":\"$SECRET_KEY\""
              fi
              PATCH_JSON="${PATCH_JSON}}}"

              echo "Patching juicefs-secret..."
              curl -s --cacert $KUBE_CA \
                -H "Authorization: Bearer $KUBE_TOKEN" \
                -H "Content-Type: application/strategic-merge-patch+json" \
                -X PATCH \
                "https://kubernetes.default.svc/api/v1/namespaces/juicefs/secrets/juicefs-secret" \
                -d "$PATCH_JSON"

              echo "Done! Secret patched."
